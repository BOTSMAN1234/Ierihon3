import asyncio
import json
import logging
import os
import re
from collections import defaultdict
from datetime import date, datetime, time, timedelta, timezone
from pathlib import Path

import aiofiles

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
)
from telegram.error import BadRequest, RetryAfter
from telegram.constants import ParseMode

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ÐÐÐ¡Ð¢Ð ÐžÐ™ÐšÐ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Ð¢ÐžÐšÐ•Ð Ð‘Ð•Ð ÐÐ¢Ð¡Ð¯ Ð˜Ð— ÐŸÐ•Ð Ð•ÐœÐ•ÐÐÐžÐ™ ÐžÐšÐ Ð£Ð–Ð•ÐÐ˜Ð¯ (Railway â†’ Variables)
TOKEN = os.getenv("BOT_TOKEN")

if not TOKEN:
    raise RuntimeError("âŒ ÐŸÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ BOT_TOKEN Ð½Ðµ Ð·Ð°Ð´Ð°Ð½Ð°")

DATA_DIR = Path("data")
DATA_DIR.mkdir(exist_ok=True)

BIRTHDAYS = []
DUTIES_TEXT = ""
SCHEDULES = {}

chat_states = defaultdict(lambda: {
    "votes": {},
    "poll_message_id": None,
    "results_message_id": None,
    "last_save": 0.0,
    "dirty": False
})

file_write_lock = asyncio.Lock()

last_birthday_sent_date = None
last_pinned_birthday_msg_id = {}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð¤ÐÐ™Ð›Ð« Ð¡ÐžÐ¡Ð¢ÐžÐ¯ÐÐ˜Ð¯ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def get_file(chat_id: int, chat_title: str) -> Path:
    safe = re.sub(r'[^a-zA-Z0-9_-]', '_', chat_title or f"chat_{chat_id}")[:40]
    return DATA_DIR / f"stolovaya_{safe}_{chat_id}.json"


async def save_state_periodically(chat_id: int, chat_title: str):
    now_ts = datetime.utcnow().timestamp()
    state = chat_states[chat_id]

    if not state["dirty"] or now_ts - state["last_save"] < 12:
        return

    async with file_write_lock:
        path = get_file(chat_id, chat_title)
        tmp = path.with_suffix(".tmp")

        async with aiofiles.open(tmp, "w", encoding="utf-8") as f:
            await f.write(json.dumps({
                "date": date.today().isoformat(),
                "votes": state["votes"],
                "poll_message_id": state["poll_message_id"],
                "results_message_id": state["results_message_id"],
            }, ensure_ascii=False, separators=(",", ":")))

        tmp.replace(path)
        state["last_save"] = now_ts
        state["dirty"] = False


async def load_state_from_file(chat_id: int, chat_title: str):
    path = get_file(chat_id, chat_title)
    if not path.exists():
        return None

    async with aiofiles.open(path, "r", encoding="utf-8") as f:
        return json.loads(await f.read())


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð”ÐÐ˜ Ð ÐžÐ–Ð”Ð•ÐÐ˜Ð¯ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def save_last_birthday_date(date_str: str):
    async with aiofiles.open(DATA_DIR / "last_birthday_sent.json", "w", encoding="utf-8") as f:
        await f.write(json.dumps({"date": date_str}))


async def load_last_birthday_date():
    global last_birthday_sent_date
    path = DATA_DIR / "last_birthday_sent.json"
    if not path.exists():
        return

    async with aiofiles.open(path, "r", encoding="utf-8") as f:
        last_birthday_sent_date = json.loads(await f.read()).get("date")


def load_static_data():
    global BIRTHDAYS, DUTIES_TEXT, SCHEDULES

    with (DATA_DIR / "data_birthdays.json").open("r", encoding="utf-8") as f:
        BIRTHDAYS = json.load(f)

    with (DATA_DIR / "data_duties.json").open("r", encoding="utf-8") as f:
        DUTIES_TEXT = json.load(f)["text"]

    with (DATA_DIR / "data_schedules.json").open("r", encoding="utf-8") as f:
        SCHEDULES = json.load(f)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ÐœÐ•ÐÐ® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MAIN_MENU = InlineKeyboardMarkup([
    [InlineKeyboardButton("ðŸ“… Ð Ð°ÑÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ", callback_data="menu_schedule")],
    [InlineKeyboardButton("ðŸ½ Ð¡Ñ‚Ð¾Ð»Ð¾Ð²Ð°Ñ", callback_data="menu_stolovaya")],
    [InlineKeyboardButton("ðŸ§¹ Ð”ÐµÐ¶ÑƒÑ€ÑÑ‚Ð²Ð°", callback_data="duties")],
    [InlineKeyboardButton("ðŸŽ‚ Ð”Ð½Ð¸ Ñ€Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ", callback_data="menu_birthdays")],
])

PROFILE_MENU = InlineKeyboardMarkup([
    [InlineKeyboardButton("ðŸ“ ÐœÐ°Ñ‚ÐµÐ¼Ð°Ñ‚Ð¸ÐºÐ° (Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ)", callback_data="profile_math")],
    [InlineKeyboardButton("ðŸ§ª Ð¥Ð¸Ð¼Ð¸Ñ (Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ)", callback_data="profile_chem")],
    [InlineKeyboardButton("ðŸ“˜ Ð‘Ð°Ð·Ð°", callback_data="profile_base")],
    [InlineKeyboardButton("â†©ï¸ ÐÐ°Ð·Ð°Ð´", callback_data="back_main")],
])


def days_menu(profile):
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ÐŸÐ½", callback_data=f"day*{profile}*pn"),
            InlineKeyboardButton("Ð’Ñ‚", callback_data=f"day*{profile}*vt"),
            InlineKeyboardButton("Ð¡Ñ€", callback_data=f"day*{profile}*sr"),
        ],
        [
            InlineKeyboardButton("Ð§Ñ‚", callback_data=f"day*{profile}*cht"),
            InlineKeyboardButton("ÐŸÑ‚", callback_data=f"day*{profile}*pt"),
        ],
        [InlineKeyboardButton("â†©ï¸ ÐÐ°Ð·Ð°Ð´", callback_data="menu_schedule")],
    ])


STOL_MAIN_MENU = InlineKeyboardMarkup([
    [InlineKeyboardButton("ðŸ“Š Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¾Ð¿Ñ€Ð¾Ñ", callback_data="stol_create_poll")],
    [InlineKeyboardButton("ðŸ“ˆ ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¸Ñ‚Ð¾Ð³Ð¸", callback_data="stol_show_results")],
    [InlineKeyboardButton("â†©ï¸ ÐÐ°Ð·Ð°Ð´", callback_data="back_main")],
])

STOL_POLL_MARKUP = InlineKeyboardMarkup([
    [InlineKeyboardButton("ðŸ½ Ð‘ÑƒÐ´Ñƒ ÐµÑÑ‚ÑŒ", callback_data="stol_eat")],
    [InlineKeyboardButton("ðŸ™… ÐÐµ Ð±ÑƒÐ´Ñƒ ÐµÑÑ‚ÑŒ", callback_data="stol_no_eat")],
    [InlineKeyboardButton("ðŸ« ÐÐµ Ð±ÑƒÐ´Ñƒ Ð² ÑˆÐºÐ¾Ð»Ðµ", callback_data="stol_absent")],
])

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð›ÐžÐ“Ð˜ÐšÐ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def get_results_text(votes):
    def fmt(v):
        return f"{v['name']} (@{v['username']})" if v.get("username") else v["name"]

    eat = [fmt(v) for v in votes.values() if v["status"] == "eat"]
    no_eat = [fmt(v) for v in votes.values() if v["status"] == "no_eat"]
    absent = [fmt(v) for v in votes.values() if v["status"] == "absent"]

    return (
        f"Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð¾Ð¿Ñ€Ð¾ÑÐ°: {len(votes)} Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²\n\n"
        f"ðŸ½ Ð‘ÑƒÐ´ÑƒÑ‚ ÐµÑÑ‚ÑŒ ({len(eat)}):\n" + ("\n".join(eat) or "â€”") + "\n\n"
        f"ðŸ™… ÐÐµ Ð±ÑƒÐ´ÑƒÑ‚ ÐµÑÑ‚ÑŒ ({len(no_eat)}):\n" + ("\n".join(no_eat) or "â€”") + "\n\n"
        f"ðŸ« ÐÐµ Ð¿Ñ€Ð¸Ð´ÑƒÑ‚ ({len(absent)}):\n" + ("\n".join(absent) or "â€”")
    )


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ñ€Ð°Ð·Ð´ÐµÐ»:", reply_markup=MAIN_MENU)


async def callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()

    chat_id = q.message.chat.id
    chat_title = q.message.chat.title or str(chat_id)
    user = q.from_user
    uid = str(user.id)

    state = chat_states[chat_id]

    if not state["votes"]:
        loaded = await load_state_from_file(chat_id, chat_title)
        if loaded:
            state.update(loaded)

    data = q.data

    if data == "menu_stolovaya":
        await q.edit_message_text("Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ:", reply_markup=STOL_MAIN_MENU)
        return

    if data == "stol_create_poll":
        state["votes"].clear()
        state["dirty"] = True

        poll = await context.bot.send_message(chat_id, "ðŸ½ ÐžÐ¿Ñ€Ð¾Ñ Ð½Ð° Ð·Ð°Ð²Ñ‚Ñ€Ð°", reply_markup=STOL_POLL_MARKUP)
        state["poll_message_id"] = poll.message_id

        res = await context.bot.send_message(chat_id, get_results_text(state["votes"]))
        state["results_message_id"] = res.message_id
        return

    if data in ("stol_eat", "stol_no_eat", "stol_absent"):
        state["votes"][uid] = {
            "name": user.first_name or "Ð‘ÐµÐ· Ð¸Ð¼ÐµÐ½Ð¸",
            "username": user.username,
            "status": data.replace("stol_", "")
        }
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=state["results_message_id"],
            text=get_results_text(state["votes"])
        )
        return


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð—ÐÐŸÐ£Ð¡Ðš â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def main():
    load_static_data()
    await load_last_birthday_date()

    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(callback))

    await app.initialize()
    await app.start()
    await app.updater.start_polling(drop_pending_updates=True)

    await asyncio.Event().wait()


if __name__ == "__main__":
    asyncio.run(main())
